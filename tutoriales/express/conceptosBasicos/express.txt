EXPRESS:

    - Curso basado en el video de youtube: https://www.youtube.com/watch?v=JmJ1WUoUIK4
    - Framework m√°s popular de nodeJs que posee las siguiente caracter√≠sticas:

        - Fu√© unos de los primeros en aparecer.
        - Es un framework unopionated:
            - No nos indica como crear la estructura del proyecto
            - Ni como escribir el proyecto.
            -  Es m√°s versatil y ligero que otros.

        - Permite crear aplicaciones grandes a√±adiendo m√≥dulos

        - Se basa en c√≥digo javascript creado por otros programadores
            - Permite usar bases de programaci√≥n creadas por otros desarroladores para desarrollar encima mi aplicaci√≥n
            - Podr√≠a usar c√≥digo de nodejs, pero tendr√≠a que estar creando mucho c√≥digo desde el inicio como:
                - Para leer archivos
                - Crear rutas de servidor
                - Asegurar la aplicaci√≥n
                - Subir archivos
                - etc
                - Evitan tener que estar creando este c√≥digo una y otra vez

        - Permite crear tiendas vituales, redes sociales y aplicaciones webs en general
        - React, angular o view se basan en nodejs
                
    - Otros frameworks:
        - happy
        - fast afy

        - NestJs. Se considera el sucesor de express
            - Ver las diferencias con express en el video: https://www.youtube.com/watch?v=EYCrmB_JvlI
            - NestJs crea una estructura de carpetas que se suele seguir
            - Express viene con una serie de paquetes definidos, que no estoy seguro que se usen, y nestJs no
                - Con nestJs debemos elegir que paquetes utilizar y que debemos tenerlos actualizados
            - nestJs esta m√°s influenciada por Angular.
            - nestJs usa typescript por defecto teniendo soporte nativo. Est√° m√°s orientado a typescript
            - nestJs tiene una curva de aprender m√°s pronunciada
            - express es mucho m√°s popular y se usa m√°s en las industrias. Es m√°s robusto y tiene pocos cambios
            - express se podr√≠a usar en proyectos m√°s peque√±os y nestJs en proyectos que necesiten mas estructuracion
            - Si no van a escarlar demasiado es recomendable usar express
            - Trabajar en equipo se mejora con nestJs
            - Ser√≠a recomendable empezar con javascript y espress. Para despues trabajar con typescript y nestJs

        - Adonis
        - lockback

    - Stacks:
        - Son conjuntos de tecnolog√≠as para crear aplicaciones completas, todas basadas en javascript
            - stack mern incluye: MongoDbm Express, React, y Node
            - stack mean incluye: Mongodb, Express, Angular y Node.

    - Instalacion de express:
        - Instalar nodejs: npm i node o descargarlo desde ubuntu software
        - Instalar express: npm i express

    - METODOS DE COMUNICACION DEL PROTOCOLO HTTP:    
        
        - get.
            
            - El cliente obtiene algo del servidor.
            - Se usa frecuentemente en el routing al entrar en una ruta determinada.
            - Es la peticion por defecto

        - post
            - El cliente le envia datos al servidor que quizas √©l guarde
            - El servidor puede devolverle datos

        - put
            - El cliente trata de actualizar algo del servidor
            - Enviamos un id que localiza el servidor y actualiza todos sus datos
        
        - delete
            - El cliente trata de eliminar algo del servidor
            - Le enviamos un id, lo busca y si lo encuentra elimina los datos

        - patch
            - Es igual que el verbo put pero solo actualiza un campo, no todo el registro
        
        - all
            - Engloba a todos los m√©todos anteriores.
            - 

        - Como probar estos m√©todos:

            - El m√©todo get se prueba de una forma y el resto de otra
            - Declaro mi routing en mi archivo index.js:

                app.get('/', (req, res) => {
                    res.send('P√°gina asociada a la raiz del proyecto cuando uso el m√©todo get')
                })

                app.get('/about', (req, res) => {
                    res.send('P√°gina asociada al Acerca de del proyecto')
                })

                app.post('/', (req, res) => {
                    res.send('P√°gina asociada a la raiz del proyecto cuando uso el m√©todo post')
                })

            - Para probar las rutas realizadas con get solo debo abrir el navegador, poner la ruta y ver el mensaje
            - Para probar los m√©todos post, put, delete, patch y el resto que valla a usar es diferente:
                - Si me encargo tambien del front hacer peticiones desde el c√≥digo de front
                - En caso contario debo simular estas peticiones mediante el uso de la extension thunder client de VS
                    - Desde el icono thunder cliente creado en la columna de la izquierda creo New request
            - Para probar un metodo all puedo usar el navegador, desde el front o thunder client
                - Encontrar√≠a las ruta usando cualquier m√©todo


    - HTTP RESPONSE

        - Son las respuestas que emite el servidor creado mediante express usando el protocolo http
            - Puede responder: texto, archivos html, pdf, txt, v√≠deos, audios, o formatos json o xml, etc.
            - Un ejemplo de responder un objeto json. Al entrar en una ruta /user devolver informaci√≥n del usuario
                - la web https://jsonformatter.curiousconcept.com/ permite comprobar si un objeto json es v√°lido

        - Los servidores creados con express devuelven un estado indicando el resultado de la operacion. Ejemplos:
            - Estado 404 significa que el servidor no encontr√≥ lo que intentaba hacer
            - Estado 500 significa error interno del servidor

            - Estado 200 indica que fue todo bien y el servidor responde con algo.
                - A veces aparece este c√≥digo de estado despues de actualizar y antes devolv√≠a otro codigo de estado
                - Esto significa que la segunda vez, cuando refresca, se almacen√≥ ya el dato en la cache

            - Estado 204 indica que fue todo bien pero el servidor no devuelve nada.            
                - Devolver√≠a solo el estado y ningun dato
                - Para ello usar√≠a le m√©todo sendStatus(Codigo de estado)

            - Estado 304 indica que se esta pidiendo un datos que no ha sido modificado
            - Puedo enviar el c√≥digo de estado que considero si uso el m√©todo sendStatus
                - Ver como se hace en la ruta /isAlive mediante el metodo get en index.js

                    
    - REQUEST BODY
    
        - Durante una peticion desde el cliente se pueden enviar distintos tipos de datos al servidor:

            - Como textos, objetos jason, archivos o datos a partir de un formulario del front
            - Estas peticiones se realizar√≠an mediante el metodo post ya que se van a enviar datos
            
            - Mediante el m√©todo use le debo indicar el dato que recibir√° el servidor:
                - Si recibe un string => app.use(express.text())
                - Si recibe un json => app.use(express.json()) 
                - Si recibe datos de un formulario => app.use(express.urlencoded({extended: false}))
                    - extended: false indica que no debe interpretar nada. Ningun dato recibido es complicado


            - Estas peticiones las puedo considerar como un objeto llamado request con el siguiente contenido:
                - endpoint. Ser√≠a la url que ha sido visitada
                - body. Ser√≠a el dato enviado, generalmente un objeto json.
                - header. Contendr√≠a informaci√≥n adicional como el tipo de dato enviado

            - Las respuestas de un servidor las obtenemos mediante un objeto llamado response
                - Este tendr√≠a la misma estructura que el objeto request anterior. (endpoint, body y header)
                - Y el c√≥digo del estado vendr√≠a dentro del header como informaci√≥n adicional

        - Podemos usar un cliente rest para simular estos envios desde el cliente a√±adiendo datos.
            - El cliente rest podr√≠a ser la extension thunder client de VS antes mencionado
            - Simulando el envio por el m√©todo que sea, a√±adiendo el endpoint
            - Selecciono Body y el tipo de dato que simulo enviar y su contenido
            - El header lo a√±adir√° thunder client de forma autom√°tica. Desde el front tendr√© que enviarlas yo.
            - Para simular el envio de datos mediante un formulario debo seleccionar body/form-encode

    - REQUEST PARAMS
        
        - Permite realizar peticiones con rutas din√°micas.
        - Se enviar√°n como un objeto con sus conjuntos propiedad-valor
        - En la ruta a√±ado : seguido del nombre de la propiedad y as√≠ declaro que es din√°mica
        - Usar√© el metodo params desde el servidor para obtenerlos
        - Desde el navegador pasar√© el valor
        - Me va a permitir envias IDs desde la barra del navegador y capturarlos desde el servidor
        - Todo par√°metro recibido es un string
            - Si quiero cambiarle su tipo uso parseInt, parseFloat, etc

    - QUERIES
    
        - Permite declarar variables y enviarlas al backend anteponiendo el caracter ?vbleEnvidada=valorEnviado
        - Desde el navegador escribimos una ruta como esta: http://localhost:3000/ruta?x=20
        - En el backend uso el metodo query y obtengo un objeto cuya propiedad es vbleEnviada y su valor es valorEnviado
            - El valor se recibe como un string al igual que en resquest params
        
        - Puedo a√±adir mas variables a√±adiendo un & por ejemplo ?vble1=valorVble1&vble2=valorVble2     
        - Puedo enviar mas de un dato en una sola vble por ejemplo ?vble1=valor1&vble1=valor2
            - El servidor recibe un objeto cuya propiedad es vble1 y su valor es una array formado por valor1 y valor2

        - Puedo acceder a las variables directamente usando el metodo query.vble

    - FUNCION MIDDLEWARE

        - Son funciones intermedias creadas por m√≠ o importadas desde express que pueden ejecutarse en express
        - Funci√≥n que se ejecuta antes de acceder a las rutas declaradas en el backend:
            - Suele usarse para registrar informacion que llega al servidor (logging y loggers)
                - A esta accion se le llama logging
                - A las funciones que registrar los datos se les llama loggers
                - Esta informacion registrada suelen ser rutas, metodos, ...

        - Implica el uso del metodo use en cuyo interior ejecutamos una funci√≥n que no es necesario llamarla
        - La declaro al principio del servidor de tal forma que todas las peticiones pasar√°n antes por ella        

        - Dispone de un par√°metro extra ademas de request y response que se llama next, que es una funcion

            - Sirve para que una vez se ejecute continue leyendo las rutas
            - Es obligatorio su presencia en los middlewares           
            
            - Es una funci√≥n muy importante para tener control en el routing. 
                - La llamo cuando quiero que continue leyendo la siguiente ruta
                - Si no la llamo enviar√© una respuesta al cliente y acabar√° la lectura del routing

            - Las funciones usadas en el routing que no son middlewares tambien pueden tener la funcion next()
                - Avanzando as√≠ en el routing llegado a este punto
                - No es frecuente

        - Puedo usar un middleware para proteger rutas:   

            - No tengo porque declarar todas los middlewares y despues las rutas.            
            - Puedo tener un middleware que obtenga informaci√≥n que llega al servidor
            - Declarar las rutas de acceso publico para todos los usuarios
            - Tener otro middleware que verifique si un usuario est√° registrado en la bbdd.
                - Si el usuario est√° registrado llamo a la funcion next y continuo con las rutas privadas
                    - Las rutas que sean privadas iran a continuacion de este segundo middleware
                    - Protegiendo estas rutas y dejando solo acceso a ellas a los usuarios registrados
                - Si no lo est√° el servidor devuelve una respuesta de usuario no registrado y no ejecuta la funcion next()

        - Existen paquetes que permiten a√±adir middleware externas desde express

            - Se suelen conocer a traves de la comunidad

            - Un ejemplo de middleware externo es morgan

                - Permite ver por consola las peticiones que van llegando
                - Evitar tener que crear un logger a mano.

                - Instalacion:

                    - Escribir en consola: npm i morgan
                    - Requerirlo: const morgan = require('morgan')
                    - Sustituyo mi logger creado a mano por: app.use(morgan())
                        - Mostrar√° en consola las peticiones mediante mensajes que puedo modificar

                        - Dentro de la funcion morgan puedo a√±adir un texto que modificar√° esos mensajes
                            - morgan('tiny')

                            - morgan('dev')
                                - Muestra el metodo de la peticion
                                - La url
                                - El estado de la peticion
                                - El tiempo de respuesta de la peticion
                                - Y cuanto pes√≥ la respuesta

                            - morgan('short')

            - Al enviar diferentes tipos de datos mediante REQUEST BODY tambien uso middlewares:

                - app.use(express.text()). Cuando recibo texto
                - app.use(express.json()). Cuando recibo un objeto json
                - app.use(express.urlencoded({extended: false})). Cuando recibo datos desde un formulario
                - Ver uso de estos ejemplos en index.js

            - En las pruebas de index.js donde envio
            - Existen diferentes middlewares de express para: 

                - Subir im√°genes
                - Comprobar si el usuario tiene valor dentro de su peticion como cookies
                - Validar datos
                - .....

    - SETTINGS

        - Permite definir variables que estar√°n presentes durante todo el script y/o reconfigurar express
            - Se definen antes de los middlewares
            - Permite tener todas esas variables en el mismo lugar
            - Un ejemplo de reconfiguracion de express ser√≠a 'case sensitive routing'
                - No es usual.
                - Fuerza a que las rutas se escriban exactamente como se definieron para ser v√°lidas
                - app.set('case sensitive routing', true)
                    - hace que una ruta definida como /Ruta solo sea valida si la escribo as√≠ en el navegador
                    - Si la dejo en false, que es el valor por defecto, /ruta ser√≠a v√°lida

            - Existen m√≥dulos que necesitan de estas configuraciones para funcionar

        - Se definen al principio del script mediante el m√©todo set y se accede a ellas mediante el m√©todo get

        - Ej: 
            const express = require("express")
            const app = express()
            app.set('vble', valor)
            app.get('vble')

        - Ver ejemplo en index.js

    - STATIC FILES

        - Si quiero enviar mas de un archivo es mejor no usar el m√©todo sendFile. Ser√≠a muy tedioso.
        - Es mejor crear una carpeta publica donde almacenar los archivos index.html, estilos.css, index.js, ...
            - Y esos archivos pasar√°n a ser publicos            

        - Para ello usar√© el middleware static propio de express donde almacenar√© los archivos mencionados

            - Al declarar el middleware a√±adir√© la ruta publica como prefijo y lo har√© al final de las rutas publicas
            - Si existieran dos archivos con el mismo nombre el prefijo me permitir√° dirijirme a uno u otro
            - En el proyecto existen dos archivos llamados note.txt, uno privado y otro p√∫blico
            - El archivo index.js situado en /tutoriales/express/conceptosBasicos hay un ejemplo del uso de este middleware

        - Se pueden tener mas de una carpeta publica
            - Los proyectos hechos en react tienen la carpeta dist como publica
            - Y podemos a√±adir otra llamada upload donde tener los archivos que queramos compartir

    - MODULO path

        - Si quiero ordenar mejor todo mi c√≥digo y dejarlo todo orgranizado en una carpeta src:        
        - Uso el modulo path para concatenar mi directorio por defecto con cada una de las carpetas publicas
        - Uso el objeto global __dirname que contiene la ruta absoluta desde mi unidad donde me encuentro
        - A√±adir el m√©todo join para unir mi directorio por defecto y la carpeta publica correspondiente
        - Permitir√≠a que si cambiamos la ubicacion de la carpeta src, la aplicaci√≥n se mantenga
        - Ver como se aplica en el archivo index.js

    - EXPRESS ROUTER

        - Concepto router:

            - Permite tener varios archivos que contengan las rutas y no almacenarlas en uno solo
            - Creo muchos archivos y los unimos todos en una aplicaci√≥n y los almaceno en una carpeta (router)

        - M√≥dulo express router:

            - Express tiene un m√≥dulo llamado router que se encarga de esta gestion
            - Las rutas almacenadas en cada uno de los archivos seran exportadas
            - index.js, el archivo que antes las tenia todas, las importar√° un index.js y las usar√°

    - TEMPLATE ENGINE:

        - Tecnolog√≠a que se a√±ade al backend que permite crear m√∫ltiples paginas que comparten interfaces o datos
        - En espa√±ol se podr√≠a traducir como "Un motor de plantillas"  
        - Permite procesar archivos html en el backend y enviarlos al frontend. 

        - Debo usarlo en caso de no usar react aplicando template engine de esta forma:
            - Envio desde el frontend informaci√≥n mediante request body, request params o request query
            - Recibe esto datos el servidor.
            - Hace su consulta en la bbdd
            - Obtiene datos que los envia mediante template engine y crea la pagina web de respuesta

        - Las p√°ginas se suelen almacenar estas en una carpeta llamada views
            - Tienen la extension .ejs y la estructura basica de un html            

        - Configuraci√≥n en settings.
            - Es necesario realizar una configuracion en settings del archivo server.js

            - Es necesario indicar en settings la carpeta y la ubicaci√≥n de las carpeta que contiene las views
                - app.set('views'. path.join(__dirname, 'views'))
                
            - Debo indicar el motor de plantillas utilizado:
                - En este caso usarems ejs y lo indico as√≠: app.set('view engine', 'ejs')

    - EJS
        - Uno de los modulos que permite implementar template engine que usare en esta app
        - Su documentaci√≥n se encuentra en este enlace: https://ejs.co/
        - Se puede descargar desde: https://www.npmjs.com/package/ejs

        - Permite leer datos, combinarlos con el html y despues enviarlos al frontend
            - Usando para ello una sintaxis para interpretar datos o ejecutar logica de javascript
                - Son etiquetas con caracteres extra√±os
                    - <%= vble %>
                - Usar condicionales
                - Unir distintas porciones de html en una sola

            - Y usando el m√©todo render, puedo renderizar las paginas
    
        - Puedo obtener datos de una bbdd, renderizar una pagina y enviar dichos datos
            -Ej: res.render(pagina de la carpeta views, {Objeto con los datos})

        - Lo instalo mediante: npm i ejs
        - Lo importo mediante la linea: require('ejs') o import si uso ECS6

    - SI USO REACT, NO DEBO USAR TEMPLATE ENINGE:

        - En lugar de que Express renderice HTML con EJS, lo que har√°s es:

            1Ô∏è‚É£ React se encarga de la interfaz de usuario y se ejecuta en el navegador.
            2Ô∏è‚É£ Express act√∫a como un servidor API y solo env√≠a JSON, no HTML.
            3Ô∏è‚É£ MongoDB almacena los datos y Express los consulta cuando React los necesita.

        - El flujo t√≠pico ser√≠a algo as√≠:

            1Ô∏è‚É£ React hace una petici√≥n HTTP (fetch, axios, etc.) a Express.
            2Ô∏è‚É£ Express recibe la petici√≥n, consulta MongoDB y devuelve los datos en formato JSON.
            3Ô∏è‚É£ React recibe los datos y los muestra en la UI.



    VOY POR EL VIDEO EN LA HORA 3 Y 16 MINUTOS. EL MOTOR DE PLANTILLAS EST√Å ANTICUADO SI YA USO REACT.
    QUIZAS NO CONTINUE APRENDIENDO DE ESTE VIDEO DEBIDO A SU FALTA DE USO.

    RECOMENDACION CHATGPT:
    Si tu meta con Express es construir APIs para consumir desde React, entonces olv√≠date de EJS y conc√©ntrate en middleware, rutas, controladores, autenticaci√≥n y bases de datos.    
    üëâ Mi consejo: cambia de video y busca uno m√°s enfocado en Express como backend para una aplicaci√≥n React. Te evitar√°s aprender cosas innecesarias.

        